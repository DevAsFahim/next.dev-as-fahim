[
  {
    "id": 1,
    "title": "Getting Started with the MERN Stack",
    "excerpt": "Learn how to set up a full-stack application using MongoDB, Next.js, React, and Node.js.",
    "content": "<p>The MERN stack is a popular JavaScript stack used for building modern web applications. It consists of MongoDB, Next.js API routes, React, and Node.js.</p>\n      \n      <h2>What is the MERN Stack?</h2>\n      <p>The MERN stack is comprised of the following technologies:</p>\n      <ul>\n        <li><strong>MongoDB</strong>: A NoSQL database that stores data in JSON-like documents.</li>\n        <li><strong>Next.js API routes</strong>: A way to create API endpoints within your Next.js application.</li>\n        <li><strong>React</strong>: A JavaScript library for building user interfaces.</li>\n        <li><strong>Node.js</strong>: A JavaScript runtime environment that executes JavaScript code outside of a web browser.</li>\n      </ul>\n      \n      <h2>Setting Up Your Development Environment</h2>\n      <p>Before you start building a MERN stack application, you need to set up your development environment. Here's how:</p>\n      \n      <h3>1. Install Node.js and npm</h3>\n      <p>Node.js is the runtime environment for executing JavaScript code server-side. npm (Node Package Manager) comes bundled with Node.js and is used to install and manage packages.</p>\n      \n      <h3>2. Install MongoDB</h3>\n      <p>MongoDB is a NoSQL database that stores data in flexible, JSON-like documents. You can download and install MongoDB from the official website or use MongoDB Atlas, a cloud-based database service.</p>\n      \n      <h3>3. Create a New React Application</h3>\n      <p>You can create a new React application using Create React App, a tool that sets up a new React project with a good default configuration.</p>\n      \n      <h3>4. Set Up Next.js API Routes</h3>\n      <p>Next.js API routes allow you to create API endpoints directly within your Next.js application. This simplifies the process of building APIs and eliminates the need for a separate Express.js server.</p>\n      \n      <h2>Building Your First MERN Stack Application</h2>\n      <p>Now that you have set up your development environment, you can start building your first MERN stack application. Here's a simple example of a to-do list application:</p>\n      \n      <h3>1. Create the Backend</h3>\n      <p>First, create a new directory for your project and initialize a new Node.js project:</p>\n      \n      <pre><code>mkdir mern-todo-app\ncd mern-todo-app\nnpm init -y</code></pre>\n      \n      <p>Install the necessary dependencies:</p>\n      \n      <pre><code>npm install mongoose cors</code></pre>\n      \n      <p>Create a new file called <code>app/api/todos/route.ts</code> (or <code>app/api/todos/route.js</code>) and set up your Next.js API route:</p>\n      \n      <pre><code>import mongoose from 'mongoose';\nimport { NextResponse } from 'next/server';\n\nconst MONGODB_URI = process.env.MONGODB_URI || 'mongodb://localhost:27017/mern-todo';\n\nasync function connectToDatabase() {\n  try {\n    if (!mongoose.connection.readyState) {\n      await mongoose.connect(MONGODB_URI);\n      console.log('Connected to MongoDB');\n    }\n  } catch (error) {\n    console.error('MongoDB connection error:', error);\n    throw new Error('Failed to connect to MongoDB');\n  }\n}\n\nconst todoSchema = new mongoose.Schema({\n  text: String,\n  completed: Boolean,\n});\n\nconst Todo = mongoose.models.Todo || mongoose.model('Todo', todoSchema);\n\nexport async function GET() {\n  await connectToDatabase();\n  try {\n    const todos = await Todo.find();\n    return NextResponse.json(todos);\n  } catch (error) {\n    console.error('Error fetching todos:', error);\n    return NextResponse.json({ message: 'Error fetching todos' }, { status: 500 });\n  }\n}\n\nexport async function POST(req) {\n  await connectToDatabase();\n  try {\n    const { text } = await req.json();\n    const todo = new Todo({\n      text: text,\n      completed: false,\n    });\n    await todo.save();\n    return NextResponse.json(todo);\n  } catch (error) {\n    console.error('Error creating todo:', error);\n    return NextResponse.json({ message: 'Error creating todo' }, { status: 500 });\n  }\n}\n\nexport async function PUT(req) {\n  await connectToDatabase();\n  try {\n    const { id } = await req.json();\n    const todo = await Todo.findById(id);\n    if (!todo) {\n      return NextResponse.json({ message: 'Todo not found' }, { status: 404 });\n    }\n    todo.completed = !todo.completed;\n    await todo.save();\n    return NextResponse.json(todo);\n  } catch (error) {\n    console.error('Error updating todo:', error);\n    return NextResponse.json({ message: 'Error updating todo' }, { status: 500 });\n  }\n}\n\nexport async function DELETE(req) {\n  await connectToDatabase();\n  try {\n    const { id } = await req.json();\n    await Todo.findByIdAndDelete(id);\n    return NextResponse.json({ message: 'Todo deleted' });\n  } catch (error) {\n    console.error('Error deleting todo:', error);\n    return NextResponse.json({ message: 'Error deleting todo' }, { status: 500 });\n  }\n}\n</code></pre>\n      \n      <h3>2. Create the Frontend</h3>\n      <p>Create a new React application:</p>\n      \n      <pre><code>npx create-react-app client\ncd client</code></pre>\n      \n      <p>Install the necessary dependencies:</p>\n      \n      <pre><code>npm install axios</code></pre>\n      \n      <p>Create a new file called TodoList.js in the src directory:</p>\n      \n      <pre><code>import React, { useState, useEffect } from 'react';\nimport axios from 'axios';\n\nfunction TodoList() {\n  const [todos, setTodos] = useState([]);\n  const [text, setText] = useState('');\n\n  useEffect(() => {\n    fetchTodos();\n  }, []);\n\n  const fetchTodos = async () => {\n    const res = await axios.get('/api/todos');\n    setTodos(res.data);\n  };\n\n  const addTodo = async (e) => {\n    e.preventDefault();\n    if (!text) return;\n    await axios.post('/api/todos', { text });\n    setText('');\n    fetchTodos();\n  };\n\n  const toggleTodo = async (id) => {\n    await axios.put('/api/todos', { id });\n    fetchTodos();\n  };\n\n  const deleteTodo = async (id) => {\n    await axios.delete('/api/todos', { id });\n    fetchTodos();\n  };\n\n  return (\n    <div>\n      <h1>Todo List</h1>\n      <form onSubmit={addTodo}>\n        <input\n          type=\"text\"\n          value={text}\n          onChange={(e) => setText(e.target.value)}\n          placeholder=\"Add a todo\"\n        />\n        <button type=\"submit\">Add</button>\n      </form>\n      <ul>\n        {todos.map((todo) => (\n          <li key={todo._id}>\n            <span\n              style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}\n              onClick={() => toggleTodo(todo._id)}\n            >\n              {todo.text}\n            </span>\n            <button onClick={() => deleteTodo(todo._id)}>Delete</button>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\nexport default TodoList;\n</code></pre>\n      \n      <h3>3. Run Your Application</h3>\n      <p>Start the frontend development server:</p>\n      \n      <pre><code>cd client\nnpm start</code></pre>\n      \n      <p>Your MERN stack application should now be running. You can access it at http://localhost:3000.</p>\n      \n      <h2>Conclusion</h2>\n      <p>In this tutorial, you learned how to set up a MERN stack development environment and build a simple to-do list application. The MERN stack is a powerful combination of technologies that allows you to build modern web applications with JavaScript throughout the entire stack.</p>\n      \n      <p>As you continue to learn and build with the MERN stack, you'll discover more advanced features and techniques that will help you create more complex and feature-rich applications.</p>\n    ",
    "date": "May 15, 2025",
    "author": "Dev AS Fahim",
    "image": "/images/blog-1.jpeg",
    "category": "Development",
    "tags": ["MERN", "MongoDB", "Next.js", "React", "Node.js"]
  },
  {
    "id": 2,
    "title": "Optimizing React Performance",
    "excerpt": "Tips and tricks to improve the performance of your React applications.",
    "content": "<p>React is a popular JavaScript library for building user interfaces, but as your application grows, you might encounter performance issues. In this article, we'll explore various techniques to optimize your React applications.</p>\n      \n      <h2>Understanding React's Rendering Process</h2>\n      <p>Before diving into optimization techniques, it's important to understand how React renders components. React uses a virtual DOM to efficiently update the actual DOM. When a component's state or props change, React creates a new virtual DOM tree and compares it with the previous one. It then updates only the parts of the actual DOM that have changed.</p>\n      \n      <h2>Common Performance Issues and Solutions</h2>\n      \n      <h3>1. Unnecessary Re-renders</h3>\n      <p>One of the most common performance issues in React applications is unnecessary re-renders. This happens when a component re-renders even though its props or state haven't changed.</p>\n      \n      <p>Solution: Use React.memo, PureComponent, or shouldComponentUpdate to prevent unnecessary re-renders.</p>\n      \n      <pre><code>// Using React.memo\nconst MyComponent = React.memo(function MyComponent(props) {\n  // Component logic\n});\n\n// Using shouldComponentUpdate\nclass MyComponent extends React.Component {\n  shouldComponentUpdate(nextProps, nextState) {\n    // Return true if you want the component to update\n    // Return false if you don't want the component to update\n    return nextProps.value !== this.props.value;\n  }\n  \n  render() {\n    // Component logic\n  }\n}</code></pre>\n      \n      <h3>2. Large Component Trees</h3>\n      <p>Large component trees can slow down your application because React has to traverse the entire tree during the reconciliation process.</p>\n      \n      <p>Solution: Split large components into smaller, more manageable ones. Use code splitting and lazy loading to load components only when needed.</p>\n      \n      <pre><code>// Using React.lazy and Suspense\nconst LazyComponent = React.lazy(() => import('./LazyComponent'));\n\nfunction MyComponent() {\n  return (\n    <React.Suspense fallback={<div>Loading...</div>}>\n      <LazyComponent />\n    </React.Suspense>\n  );\n}</code></pre>\n      \n      <h3>3. Expensive Calculations</h3>\n      <p>Performing expensive calculations in your components can slow down your application, especially if these calculations are performed on every render.</p>\n      \n      <p>Solution: Use useMemo to memoize expensive calculations and useCallback to memoize functions.</p>\n      \n      <pre><code>// Using useMemo\nconst memoizedValue = useMemo(() => {\n  // Perform expensive calculation\n  return computeExpensiveValue(a, b);\n}, [a, b]); // Only recompute if a or b changes\n\n// Using useCallback\nconst memoizedCallback = useCallback(() => {\n  // Function logic\n  doSomething(a, b);\n}, [a, b]); // Only recreate if a or b changes</code></pre>\n      \n      <h3>4. Inefficient List Rendering</h3>\n      <p>Rendering large lists can be a performance bottleneck, especially if the list items are complex components.</p>\n      \n      <p>Solution: Use virtualization to render only the items that are currently visible in the viewport. Libraries like react-window and react-virtualized can help with this.</p>\n      \n      <pre><code>// Using react-window\nimport { FixedSizeList } from 'react-window';\n\nfunction MyList({ items }) {\n  const Row = ({ index, style }) => (\n    <div style={style}>\n      {items[index]}\n    </div>\n  );\n  \n  return (\n    <FixedSizeList\n      height={500}\n      width={300}\n      itemCount={items.length}\n      itemSize={35}\n    >\n      {Row}\n    </FixedSizeList>\n  );\n}</code></pre>\n      \n      <h3>5. Unoptimized Context API Usage</h3>\n      <p>The Context API is a powerful feature in React, but it can cause performance issues if not used correctly. When a context value changes, all components that consume that context will re-render, even if they don't use the changed value.</p>\n      \n      <p>Solution: Split your context into smaller, more focused contexts. Use memoization to prevent unnecessary re-renders.</p>\n      \n      <pre><code>// Split context into smaller contexts\nconst ThemeContext = React.createContext();\nconst UserContext = React.createContext();\n\n// Use memoization with context\nconst MyComponent = React.memo(function MyComponent() {\n  const theme = useContext(ThemeContext);\n  // Component logic\n});</code></pre>\n      \n      <h2>Tools for Performance Monitoring</h2>\n      \n      <h3>React DevTools Profiler</h3>\n      <p>The React DevTools Profiler is a powerful tool for identifying performance issues in your React applications. It allows you to record and analyze component renders, helping you identify which components are rendering unnecessarily or taking too long to render.</p>\n      \n      <h3>Lighthouse</h3>\n      <p>Lighthouse is an open-source tool from Google that audits web pages for performance, accessibility, and more. It provides actionable insights and recommendations for improving your application.</p>\n      \n      <h3>Web Vitals</h3>\n      <p>Web Vitals is a Google initiative that provides unified guidance for quality signals that are essential to delivering a great user experience on the web. The Core Web Vitals are a subset of Web Vitals and include metrics like Largest Contentful Paint (LCP), First Input Delay (FID), and Cumulative Layout Shift (CLS).</p>\n      \n      <h2>Conclusion</h2>\n      <p>Optimizing React performance is an ongoing process that requires a good understanding of how React works and the specific performance bottlenecks in your application. By applying the techniques discussed in this article and using the right tools for performance monitoring, you can significantly improve the performance of your React applications.</p>\n      \n      <p>Remember, premature optimization is the root of all evil. Always measure first to identify the actual performance bottlenecks in your application before applying optimization techniques.</p>\n    ",
    "date": "April 28, 2025",
    "author": "Dev AS Fahim",
    "image": "/images/blog-2.jpg",
    "category": "React",
    "tags": ["React", "Performance", "Optimization"]
  },
  {
    "id": 3,
    "title": "A Beginner's Guide to Tailwind CSS",
    "excerpt": "Discover how to style your web applications using Tailwind CSS, a utility-first CSS framework.",
    "content": "<p>Tailwind CSS is a modern utility-first CSS framework that helps you build custom designs directly in your HTML. Unlike traditional CSS frameworks, Tailwind doesn't impose design decisions—you create your own components and layout styles using utility classes.</p><h2>Why Use Tailwind CSS?</h2><ul><li><strong>Highly customizable:</strong> Tailwind lets you configure your design system using a config file.</li><li><strong>No more naming classes:</strong> You use pre-defined utility classes instead of writing custom CSS.</li><li><strong>Fast prototyping:</strong> Rapidly design UI without leaving your HTML file.</li></ul><h2>Installing Tailwind CSS</h2><p>You can install Tailwind using npm:</p><pre><code>npm install -D tailwindcss postcss autoprefixer\nnpx tailwindcss init -p</code></pre><p>Then configure your <code>tailwind.config.js</code> and include Tailwind in your CSS:</p><pre><code>@tailwind base;\n@tailwind components;\n@tailwind utilities;</code></pre><h2>Basic Example</h2><p>Here's a simple button using Tailwind:</p><pre><code>&lt;button class=\"bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded\"&gt;\n  Click me\n&lt;/button&gt;</code></pre><h2>Conclusion</h2><p>Tailwind CSS helps you build fast, responsive, and custom UIs with ease. It might take a little time to get used to utility-first styling, but once you do, your development workflow will become more efficient.</p>",
    "date": "May 3, 2025",
    "author": "Dev AS Fahim",
    "image": "/images/blog-3.jpeg",
    "category": "CSS",
    "tags": ["Tailwind", "CSS", "Styling"]
  },
  {
    "id": 4,
    "title": "Understanding JWT Authentication in MERN Applications",
    "excerpt": "Secure your MERN stack apps with JSON Web Tokens (JWT) for user authentication.",
    "content": "<p>JWT (JSON Web Token) is a popular method for securely transmitting information between parties. In MERN stack applications, it is commonly used for handling authentication and protecting routes.</p><h2>How JWT Works</h2><ol><li>User logs in with credentials.</li><li>Server verifies and returns a signed JWT.</li><li>The client stores the JWT (typically in localStorage or cookies).</li><li>For each request, the client sends the token in headers.</li><li>Server verifies the token before serving the request.</li></ol><h2>Installing Dependencies</h2><pre><code>npm install jsonwebtoken bcryptjs</code></pre><h2>Creating and Verifying Tokens</h2><p>In your API route or Express.js backend, use:</p><pre><code>const jwt = require('jsonwebtoken');\nconst token = jwt.sign({ id: user._id }, 'secret', { expiresIn: '1h' });</code></pre><p>To verify:</p><pre><code>jwt.verify(token, 'secret', (err, decoded) => {\n  if (err) return res.sendStatus(403);\n  req.user = decoded;\n});</code></pre><h2>Conclusion</h2><p>JWT helps secure your API endpoints while allowing stateless, scalable authentication. Pair it with password hashing (bcrypt) and HTTPS for even stronger security.</p>",
    "date": "May 6, 2025",
    "author": "Dev AS Fahim",
    "image": "/images/blog-4.jpg",
    "category": "Authentication",
    "tags": ["JWT", "Authentication", "Security", "MERN"]
  },
  {
    "id": 5,
    "title": "Managing State in React: useState vs useReducer",
    "excerpt": "Compare useState and useReducer to understand which state management hook fits your needs.",
    "content": "<p>React offers two main hooks for managing state in function components: <code>useState</code> and <code>useReducer</code>. Choosing the right one depends on the complexity of the state logic in your component.</p><h2>useState</h2><p>Best for simple states like toggles, form inputs, counters, etc.</p><pre><code>const [count, setCount] = useState(0);\nsetCount(count + 1);</code></pre><h2>useReducer</h2><p>Ideal for managing more complex state logic or multiple state variables that depend on each other.</p><pre><code>const initialState = { count: 0 };\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'increment': return { count: state.count + 1 };\n    case 'decrement': return { count: state.count - 1 };\n    default: throw new Error();\n  }\n}\n\nconst [state, dispatch] = useReducer(reducer, initialState);</code></pre><h2>Conclusion</h2><p>If your state updates are simple and isolated, stick with <code>useState</code>. If your state is complex or involves many interrelated values, <code>useReducer</code> is a better choice.</p>",
    "date": "May 7, 2025",
    "author": "Dev AS Fahim",
    "image": "/images/blog-5.webp",
    "category": "React",
    "tags": ["React", "useState", "useReducer", "State Management"]
  },
  {
    "id": 6,
    "title": "Deploying Your MERN App to Vercel and MongoDB Atlas",
    "excerpt": "Step-by-step guide to deploying a full-stack MERN app using Vercel and MongoDB Atlas.",
    "content": "<p>Deploying your MERN stack application doesn't have to be complicated. Vercel provides seamless deployment for Next.js frontend and API routes, while MongoDB Atlas offers a cloud-hosted database solution.</p><h2>1. Push Your Code to GitHub</h2><p>Ensure your project is version-controlled and pushed to a GitHub repository.</p><h2>2. Set Up MongoDB Atlas</h2><p>Create a cluster on MongoDB Atlas, add a database user, and get your connection string. Update your <code>.env</code> file with <code>MONGODB_URI</code>.</p><h2>3. Deploy to Vercel</h2><ol><li>Go to <a href=\"https://vercel.com/\">vercel.com</a></li><li>Import your GitHub repository</li><li>Set environment variables</li><li>Click Deploy</li></ol><h2>4. Test Your App</h2><p>Once deployed, visit your Vercel-provided URL to see your full-stack app in production!</p><h2>Conclusion</h2><p>By combining Vercel and MongoDB Atlas, you get a scalable, cloud-based infrastructure without managing servers or databases manually.</p>",
    "date": "May 8, 2025",
    "author": "Dev AS Fahim",
    "image": "/images/blog-6.webp",
    "category": "Deployment",
    "tags": ["Deployment", "Vercel", "MongoDB Atlas", "MERN"]
  }
]
